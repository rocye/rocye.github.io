<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[06、Hystrix - 断路器之在Feign中的使用]]></title>
    <url>%2FSpringCloud-006%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Eureka Version：2.0.0.RELEASE Feign Version：2.0.0.RELEASE Hystrix Version：1.4.4.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在上一篇的文章中已经介绍了Hystrix在Ribbon中的使用，我们知道Ribbon和Feign所完成的功能都是服务消费，本篇文章将会介绍Hystrix断路器在Feign中的使用。 修改itest-feign工程加入断路器1. 不需要修改pom文件 如果只是开启Feign的断路器功能不需要在pom文件中额外加入hystrix依赖 2. 修改相关代码 (1) Step：添加断路器回调方法，实现先前接口IFeignService新建回调类：FeignServiceHystrix (2) Step：然后修改接口IFeignService指定回调类 (3) Step：最后还需要修改application.yml开启断路器功能 3. 启动项目进行测试 (1) Step：先后启动itest-server，itest-client，itest-feign三个工程后打开: http://localhost:8761 可以看到如下页面 (2) Setp：打开浏览器输入: http://localhost:8765/testFeign?name=rocye 可以看到如下页面 (3) Setp：接下来关闭itest-client工程，查看断路器是否生效（需要等几秒刷新上面的页面） 由此可见，断路器已经生效了。 4. 加入Hystrix Dashboard (断路器仪表盘) (1) Step：在pom文件中加入hystrix dashboard依赖 12345678910111213141516&lt;!-- 2.加入断路器仪表盘功能 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt; (2) Setp：在启动类上加入注解@EnableHystrixDashboard用于开启断路器仪表盘功能，同时加入hystrix.stream的Servlet (3) Setp：重启itest-feign工程，打开: http://localhost:8765/hystrix 页面 (4) Setp：然后输入监测地址：http://localhost:8765/hystrix.stream 点击“Moniter Stream”，接下来可以在浏览器中打开: http://localhost:8765/testFeign?name=rocye 多刷新几次可以看到监测的效果如下所示 源码下载：https://github.com/rocye/SpringCloudStudy 总结Feign底层整合了Ribbon，两者相比较而言，声明式的Feign用起来更方便。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_clientshttps://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_dashboardhttps://blog.csdn.net/forezp/article/details/69934399https://blog.csdn.net/yejingtao703/article/details/77683102]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Hystrix</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05、Hystrix - 断路器之在Ribbon中的使用]]></title>
    <url>%2FSpringCloud-005%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Eureka Version：2.0.0.RELEASE Ribbon Version：2.0.0.RELEASE Hystrix Version：1.4.4.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud中可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是常说的“雪崩”效应。为了解决这个问题，业界提出了断路器模型。 断路器简介Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图：较底层的服务如果出现故障，会导致连锁故障。当对特定服务的调用不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。 修改itest-ribbon工程加入断路器1. 修改工程pom.xml文件 在pom文件中加入hystrix依赖 123456&lt;!-- 2.加入断路器功能 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt; 2. 修改相关代码 (1) Step：在启动类上加入注解@EnableHystrixet用于开启断路器功能 (2) Step：然后在测试类TestService对应的接口方法加入注解@HystrixCommand 定义断路器回调方法 123public String testError(String name) &#123; return "hello " + name + ", happen error!";&#125; 3. 启动项目进行测试 (1) Step：先后启动itest-server，itest-client，itest-ribbon三个工程后打开: http://localhost:8761 可以看到如下页面 (2) Setp：打开浏览器输入: http://localhost:8764/testRibbon?name=rocye 可以看到如下页面 (3) Setp：接下来关闭itest-client工程，查看断路器是否生效（需要等几秒刷新上面的页面） 由此可见，断路器已经生效了。 4. 加入Hystrix Dashboard (断路器仪表盘) (1) Step：在pom文件中加入hystrix dashboard依赖 1234567891011&lt;!-- 3.加入断路器仪表盘功能 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt; PS：手动修改POM文件后，如果发现依赖没生效，可以Reimport解决，如下所示 刷新完后看到最终的依赖如下所示 (2) Setp：在启动类上加入注解@EnableHystrixDashboard用于开启断路器仪表盘功能 (3) Setp：重启itest-ribbon工程，打开: http://localhost:8764/hystrix 页面 然后输入监测地址：http://localhost:8764/hystrix.stream 点击“Moniter Stream” 但是无法正常显示数据而是显示：Unable to connect to Command Metric Stream. 查看日志发现报 404 错误，是因为hystrix.stream地址找不到 (4) Setp：解决办法是需要加入hystrix.stream的Servlet 12345678910//断路器仪表盘功能(解决hystrix.stream : 404 : HTTP/1.1 404 )@Beanpublic ServletRegistrationBean getServlet()&#123; HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings("/hystrix.stream"); registrationBean.setName("HystrixMetricsStreamServlet"); return registrationBean;&#125; (5) Setp：然后重启itest-ribbon工程，再次打开: http://localhost:8764/hystrix 页面输入: http://localhost:8764/hystrix.stream 点击按钮就不再报上面的错了，接下来可以在浏览器中打开: http://localhost:8764/testRibbon?name=rocye 多刷新几次可以看到监测的效果如下所示 PS：实心圆：颜色代表健康度（绿-黄-红-橙递减），大小代表并发量；曲线：请求量的变化；其他主要参数如下图红色字体部分： 源码下载：https://github.com/rocye/SpringCloudStudy 总结以上是单结点服务的统计，相对简单，但是生产上为了服务的健壮性都是多结点，当被监控的服务变成了多个，在Dashboard之前需要一个收集器Turbine，此组件以后再专门介绍。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_clientshttps://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_dashboardhttps://blog.csdn.net/forezp/article/details/69934399https://blog.csdn.net/yejingtao703/article/details/77683102]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Ribbon</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04、Feign - 声明式REST客户端]]></title>
    <url>%2FSpringCloud-004%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在上一篇文章中，我们介绍了通过RestTemplate和Ribbon的服务调用及负载均衡的使用，在Spring Cloud中服务之间通过restful方式调用除了前面介绍的Ribbon外还有一种即是本篇要介绍的Feign。 Feign简介Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。 创建Feign客户端1. 在父工程的基础上创建一个Module子工程用作Ribbon负载均衡器 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery,Web及Feign依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 1234567891011server: port: 8765spring: application: name: itest-feigneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 3. 修改相关代码 (1) Step：在启动类上加入注解@EnableEurekaClient和@EnableFeignClients (2) Step：创建feign接口，通过@FeignClient(“服务名”)，来指定调用哪个服务及具体的接口 (3) Step：创建TestController类用于调用IFeignService进行测试 注：这里注入IFeignService接口时可能会在某些IDE中报语法错，可以在上面的接口中加入@Service注解解决些问题 4. 启动项目进行测试 (1) Step：先启动Eureka服务端itest-server，然后修改启动配置，先启动itest-client端口8762，再启动itest-client端口8763 打开: http://localhost:8761 可以看到itest-client两个实例 (2) Setp：最后启动Feign客户端，刷新上面的页面可以看到itest-feign实例 最终我们启动了如下四个实例 (3) Setp：打开浏览器输入: http://localhost:8765/testFeign?name=rocye 多刷新几次页面可以看到8762和8763端口交替出现 由此可见，已经达到了负载均衡的效果。 源码下载：https://github.com/rocye/SpringCloudStudy 总结 服务注册中心：itest-server 端口为8761 两个测试用的服务实例：itest-client 端口为8762和8763，都注册到了Eureka服务端 服务消费实例(即负载均衡器)：itest-feign端口为8765，也注册到了Eureka服务端 从实践上看，采用feign的方式更优雅，而且feign内部也使用了ribbon做负载均衡 参考文章：https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-feignhttps://blog.csdn.net/forezp/article/details/69808079https://blog.csdn.net/jrn1012/article/details/77837658]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03、Ribbon - 客户端负载均衡器]]></title>
    <url>%2FSpringCloud-003%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在上一篇文章中，我们介绍了使用Eureka作为服务注册中心，在服务启动后，各个微服务会将自己注册到Eureka server。那么服务之间是如何调用？又是如何进行负载均衡的？本文将介绍服务的调用及负载均衡器Ribbon的使用。 创建Ribbon负载均衡器1. 在父工程的基础上创建一个Module子工程用作Ribbon负载均衡器 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery,Web及Ribbon依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 1234567891011server: port: 8764spring: application: name: itest-ribboneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 3. 修改相关代码 (1) Step：在启动类上加入注解@EnableEurekaClient，再通过@Bean注入restTemplate，并通过@LoadBalanced开启负载均衡 (2) Step：创建测试类TestService并注入restTemplate，用来调用itest-client服务的”/test”接口 (3) Step：创建TestController类用于调用TestService进行测试 4. 启动项目进行测试 (1) Step：先启动Eureka服务端itest-server，然后修改启动配置，先启动itest-client端口8762，再启动itest-client端口8763 打开: http://localhost:8761 可以看到itest-client两个实例 (2) Setp：最后启动ribbon负载均衡器，刷新上面的页面可以看到itest-ribbon实例 最终我们启动了如下四个实例 (3) Setp：打开浏览器输入: http://localhost:8764/testRibbon?name=rocye 多刷新几次页面可以看到8762和8763端口交替出现 由此可见，已经达到了负载均衡的效果。 源码下载：https://github.com/rocye/SpringCloudStudy 总结 服务注册中心：itest-server 端口为8761 两个测试用的服务实例：itest-client 端口为8762和8763，都注册到了Eureka服务端 服务消费实例(即负载均衡器)：itest-ribbon 端口为8764，也注册到了Eureka服务端 Ribbon是对服务之间调用做负载，是服务之间的负载均衡，Zuul是可以对外部请求做负载均衡 PS：Zuul的负载均衡功能是针对外部请求做负载。客户端ribbon的负载均衡，解决的是服务发起方（在Eureka注册的服务）对被调用的服务的负载，比如我们查询商品服务要调用显示库存和商品明细服务，通过商品服务的接口将两个服务组合，可以减少外部应用的请求。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-ribbonhttps://blog.csdn.net/forezp/article/details/69788938https://blog.csdn.net/jrn1012/article/details/77837658]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02、Eureka - 服务的注册与发现]]></title>
    <url>%2FSpringCloud-002%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Sping Boot Version：2.0.3.RELEASE 创建Eureka服务器 (eureka server)1. 创建一个Maven主工程 (1) Step：这里不勾选“Create from archetype” (2) Step：自定义GroupId和ArtifactId (3) Step：自定义工程名及路径 (4) Step：创建完成后如下图，因为是空的父工程所以可以将src文件夹删除 2. 在父工程的基础上创建一个Module子工程用作Eureka服务器 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里只需要选择Eureka服务端依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 3. 修改工程配置文件类型为YML并加入配置 (1) Step：修改application.properties为application.yml（注：本工程配置文件将全部采用YML格式） (2) Step：在配置文件中加入如下配置，其中将registerWithEureka和fetchRegistry设置为false标识此为服务端 1234567891011server: port: 8761eureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 4. 在启动类上加入注解@EnableEurekaServer 启动itest-server工程，在浏览器中打开：http://localhost:8761 看到下图所示页面表示Eureka服务端已创建成功 创建Eureka客户端 (eureka client)1. 在父工程的基础上创建一个Module子工程用作Eureka客户端 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery和Web依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置，其中service-url(或serviceUrl)配置成服务端地址 1234567891011server: port: 8762spring: application: name: itest-clienteureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 3. 在启动类上加入注解@EnableEurekaClient 4. 依次启动itest-server和itest-client工程，打开：http://localhost:8761 看到下图所示页面表示Eureka节点已创建成功 PS：测试Eureka节点关闭被服务端踢出需要正常退出，不能强制关闭，如下图 5. 创建测试的RestController(上面加入的Web依赖在这里用到) 6. 重启itest-client工程，在浏览器中打开：http://localhost:8762/test?name=rocye 看到下图所示页面 源码下载：https://github.com/rocye/SpringCloudStudy 总结基于IntelliJ IDEA开发工具构建Spring Cloud工程非常简单和方便，合理利用配置步骤中的选择来生成配置文件能减少不必要的错误。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-eureka-serverhttps://springcloud.cc/spring-cloud-dalston.html#_service_discovery_eureka_clientshttps://blog.csdn.net/forezp/article/details/69696915]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01、从微服务框架到SpringCloud]]></title>
    <url>%2FSpringCloud-001%2F</url>
    <content type="text"><![CDATA[什么是微服务框架对于微服务基础框架可以看作是微服务治理架构的核心内容，包括了对微服务模块的全生命周期管理能力，这个能力包括了微服务网关APP，DevOps，Docker和云集成，安全，负载均衡，服务注册和发现等诸多能力。微服务基础框架确实不是简单的微服务网关，而是对整个微服务基础环境的支撑和管控。 Netflix的微服务框架Netflix是一家成功实践微服务架构的互联网公司，几年前，Netflix把几乎整个微服务框架栈开源贡献给了社区，这些框架和组件包括： Eureka：服务注册发现框架 Zuul：服务网关 Karyon：服务端框架 Ribbon：客户端框架 Hystrix：服务容错组件 Archaius：服务配置组件 Servo：Metrics组件 Blitz4j：日志组件 下图展示了基于这些组件构建的一个微服务框架体系： Netflix的开源框架组件已经在Netflix的大规模分布式微服务环境中经过多年的生产实战验证，正逐步被社区接受为构造微服务框架的标准组件。Pivotal去年推出的Spring Cloud开源产品，主要是基于对Netflix开源组件的进一步封装，方便Spring开发人员构建微服务基础框架。 Spring CloudSpring Cloud正是对Netflix的多个开源组件进一步的封装而成，同时又实现了和云端平台及Spring Boot开发框架很好的集成。Spring Cloud 为开发者提供了在分布式系统（配置管理，服务发现，熔断，路由，微代理，控制总线，一次性token，全局锁，leader选举，分布式session，集群状态等等）中快速构建的工具，使用Spring Cloud的开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。 Spring Cloud Netflix，该项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路有（Zuul），客户端负载均衡（Ribbon）等。 当然Spring Cloud还有额外扩展的其它很多组件，包括了服务链路监控和跟踪（很关键的一个功能），消息总线，数据流处理，批量任务处理等。而对于整个Spring Cloud微服务框架简单来说，即是：你只要划分到你的微服务组件和模块，并定义好需要暴露的API接口，那么剩下的整个开发和传统方式没有太大的区别，你开发完成的组件集成起来就是一个分布式可扩展的微服务环境。里面设计到的接口发布，服务注册，服务调用和路由，服务监控，健康检测和流控等都会由微服务框架来帮你完成。 PS：正是有了成熟的微服务框架，我们才更应该将微服务架构设计重心从技术底层转移到组件划分和接口设计上。 Spring Cloud VS DubboR1：背景Dubbo：是阿里巴巴服务化治理的核心框架，并被广泛应用于阿里巴巴集团的各成员站点。 Spring Cloud：是Spring Source的产物，Spring社区的强大背书可以说是Java企业界最有影响力的组织了，除了Spring Source之外，还有Pivotal和Netfix是其强大的后盾与技术输出。其中Netflix开源的整套微服务架构套件是Spring Cloud的核心。 R2：社区活跃度我们选择一个开源框架，社区的活跃度是我们极为关注的一个要点。社区越活跃，解决问题的速度越快，框架也会越来越完善，不然当我们碰到问题，就不得不自己解决。而对于团队来说，也就意味着我们不得不自己去维护框架的源码，这对于团队来说也将会是一个很大的负担。 Dubbo ：https://github.com/dubbo Spring Cloud ：https://github.com/spring-cloud 小结：在社区活跃度上，Spring Cloud毋庸置疑的优于Dubbo，这对于没有大量精力与财力维护这部分开源内容的团队来说，Spring Cloud会是更优的选择。 R3：架构完整度根据微服务架构在各方面的要素，看看Spring Cloud和Dubbo都提供了哪些支持： Dubbo Spring Cloud 服务注册中心 Zookeeper Spring Cloud Netflix Eureka 服务调用方式 RPC REST API 服务网关 无 Spring Cloud Netflix Zuul 断路器 不完善 Spring Cloud Netflix Hystrix 分布式配置 无 Spring Cloud Config 服务跟踪 无 Spring Cloud Sleuth 消息总线 无 Spring Cloud Bus 数据流 无 Spring Cloud Stream 批量任务 无 Spring Cloud Task …… …… …… Dubbo对于上表中总结为“无”的组件不代表不能实现，而只是Dubbo框架自身不提供，需要另外整合以实现对应的功能，比如： 分布式配置：可以使用淘宝的diamond、百度的disconf来实现分布式配置管理。但是Spring Cloud中的Config组件除了提供配置管理之外，由于其存储可以使用git，因此它天然的实现了配置内容的版本管理，可以完美的与应用版本管理整合起来。服务跟踪：可以使用京东开源的Hydra批量任务：可以使用当当开源的Elastic-Job…… R4：对比总结通过上面几个环节上的分析，打个不恰当的比喻：使用Dubbo构建的微服务架构就像组装电脑，各环节我们的选择自由度很高，但是最终结果很有可能因为一条内存质量不行就点不亮了，总是让人不怎么放心，但是如果你是一名高手，那这些都不是问题；而Spring Cloud就像品牌机，在Spring Source的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性，但是如果要在使用非原装组件外的东西，就需要对其基础有足够的了解。 参考文章：http://blog.sina.com.cn/s/blog_493a84550102wkna.htmlhttp://blog.sina.com.cn/s/blog_493a84550102wkp2.htmlhttp://blog.didispace.com/microservice-framework/]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务框架</tag>
      </tags>
  </entry>
</search>
