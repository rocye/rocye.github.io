<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[02、为什么使用Lambda表达式]]></title>
    <url>%2FJAVA8-002%2F</url>
    <content type="text"><![CDATA[Lambda是一种匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。 原来的匿名内部类1234567Comparator&lt;Integer&gt; com = new Comparator&lt;Integer&gt;()&#123; @Override public int compare(Integer o1, Integer o2) &#123; return Integer.compare(o1, o2); &#125;&#125;;TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;(com); 现在的Lambda表达式12Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;(com); 具体业务需求分析1、基础数据○ 定义员工类123456public class Employee &#123; private int id; private String name; private int age; private double salary;&#125; ○ 定义初始值1234567List&lt;Employee&gt; emps = Arrays.asList( new Employee(101, "张三", 18, 9999.99), new Employee(102, "李四", 59, 6666.66), new Employee(103, "王五", 28, 3333.33), new Employee(104, "赵六", 8, 7777.77), new Employee(105, "田七", 38, 5555.55)); 2、具体需求最原始的做法，来一个需求就要写一个过滤方法，代码冗余 ○ 需求1：获取公司中年龄小于35的员工信息123456789public List&lt;Employee&gt; filterEmployeeAge(List&lt;Employee&gt; emps)&#123; List&lt;Employee&gt; list = new ArrayList&lt;&gt;(); for (Employee emp : emps) &#123; if(emp.getAge() &lt;= 35)&#123; list.add(emp); &#125; &#125; return list;&#125; 123456public void test3()&#123; List&lt;Employee&gt; list = filterEmployeeAge(emps); for (Employee employee : list) &#123; System.out.println(employee); &#125;&#125; ○ 需求2：获取公司中工资大于 5000 的员工信息123456789public List&lt;Employee&gt; filterEmployeeSalary(List&lt;Employee&gt; emps)&#123; List&lt;Employee&gt; list = new ArrayList&lt;&gt;(); for (Employee emp : emps) &#123; if(emp.getSalary() &gt;= 5000)&#123; list.add(emp); &#125; &#125; return list;&#125; 123456public void test4()&#123; List&lt;Employee&gt; list = filterEmployeeSalary(emps); for (Employee employee : list) &#123; System.out.println(employee); &#125;&#125; 3、优化方式一：策略设计模式只需一个过滤方法，不用写冗余代码，有新需求只需要添加新的策略实现类 即可，在JAVA7中算是最优的设计模式优化方法；缺点是每次都要创建一个策略实现类。(1) 创建策略接口或抽象类：123public interface MyPredicate&lt;T&gt; &#123; public boolean test(T t);&#125; (2) 只需一个过滤方法：123456789public List&lt;Employee&gt; filterEmployee(List&lt;Employee&gt; emps, MyPredicate&lt;Employee&gt; mp)&#123; List&lt;Employee&gt; list = new ArrayList&lt;&gt;(); for (Employee employee : emps) &#123; if(mp.test(employee))&#123; list.add(employee); &#125; &#125; return list;&#125; (3) 需求1 的策略实现类：123456public class FilterEmployeeForAge implements MyPredicate&lt;Employee&gt;&#123; @Override public boolean test(Employee t) &#123; return t.getAge() &lt;= 35; &#125;&#125; (4) 需求2 的策略实现类：123456public class FilterEmployeeForSalary implements MyPredicate&lt;Employee&gt; &#123; @Override public boolean test(Employee t) &#123; return t.getSalary() &gt;= 5000; &#125;&#125; (5) 测试一下如何调用：1234567891011121314@Testpublic void test4()&#123; List&lt;Employee&gt; list = filterEmployee(emps, new FilterEmployeeForAge()); for (Employee employee : list) &#123; System.out.println(employee); &#125; System.out.println("------------------------------------------"); List&lt;Employee&gt; list2 = filterEmployee(emps, new FilterEmployeeForSalary()); for (Employee employee : list2) &#123; System.out.println(employee); &#125;&#125; 4、优化方式二：匿名内部类在策略模式优化方法的基础上用匿名内部类的方式减少类文件的创建。123456789101112@Testpublic void test5()&#123; List&lt;Employee&gt; list = filterEmployee(emps, new MyPredicate&lt;Employee&gt;() &#123; @Override public boolean test(Employee t) &#123; return t.getId() &lt;= 103; &#125; &#125;); for (Employee employee : list) &#123; System.out.println(employee); &#125;&#125; 5、优化方式三：Lambda表达式在策略模式优化方法的基础上用Lambda表达式简化匿名内部类多余的代码。12345678910@Testpublic void test6()&#123; List&lt;Employee&gt; list = filterEmployee(emps, (e) -&gt; e.getAge() &lt;= 35); list.forEach(System.out::println); System.out.println("------------------------------------------"); List&lt;Employee&gt; list2 = filterEmployee(emps, (e) -&gt; e.getSalary() &gt;= 5000); list2.forEach(System.out::println);&#125; 6、优化方式四：Stream API假定在没有前面任何优化方法前提下，直接用Stream解决。123456@Testpublic void test7()&#123; emps.stream().filter((e) -&gt; e.getAge() &lt;= 35).forEach(System.out::println); System.out.println("----------------------------------------------"); emps.stream().map(Employee::getName).limit(3).sorted().forEach(System.out::println);&#125; 总结Lambda表达式有没有相当简洁。]]></content>
      <categories>
        <category>JAVA8笔记</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09、SpringCloudConfig - 分布式配置中心]]></title>
    <url>%2FSpringCloud-009%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Eureka Version：2.0.0.RELEASE Spring Cloud Config Version：2.0.0.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在分布式系统中，由于服务数量巨大，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件Spring Cloud Config，它支持配置数据放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在Spring Cloud Config组件中，分两个角色：Config Server和Config Client，业界也有些知名的同类开源产品，比如百度的Disconf。 相比同类产品Spring Cloud Config最大的优势是和Spring无缝集成，支持Spring里面Environment和PropertySource的接口，对于已有的Spring应用程序的迁移成本非常低，在配置获取的接口上是完全一致，结合SpringBoot可使你的项目有更加统一的标准（包括依赖版本和约束规范），避免了应为集成不同开软件源造成的依赖版本冲突。 创建服务端配置远程Git仓库在本地创建服务端配置文件的仓库并上传到Github，其中包括三个配置文件：application-dev.yml、application-pro.yml及application-test.yml，具体的Github地址：https://github.com/rocye/SpringCloudConfig/tree/master/springcloudstudy 具体内容如下： 创建Config Server工程1. 在父工程的基础上创建一个Module子工程用作Config Server (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery及Config Server依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 1234567891011121314151617181920server: port: 8000spring: application: name: config-server cloud: config: label: master server: git: uri: https://github.com/rocye/SpringcloudConfig/ searchPaths: springcloudstudy# username: ***# password: ***eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ PS：本文使用的是公共仓库不需要用户名和密码，如果是私有仓库需要配置用户名和密码。 3. 修改相关代码并启动测试 (1) Step：在启动类上加入注解@EnableEurekaClient和@EnableConfigServer (2) Step：先后启动itest-server和config-server两个工程后打开测试页面： 测试地址：http://localhost:8000/springcloudstudy/dev 测试地址：http://localhost:8000/springcloudstudy/pro 测试地址：http://localhost:8000/springcloudstudy/test 由此可见，Config Server工程已创建成功，已经可以远程获取配置信息了。 Http请求地址和资源文件映射如下：/{application}/{profile}[/{label}]/{application}-{profile}.yml/{label}/{application}-{profile}.yml/{application}-{profile}.properties/{label}/{application}-{profile}.properties 关于application.yml与bootstrap.ymlSpringBoot默认支持properties和YAML两种格式的配置文件。前者格式简单，但是只支持键值对。如果需要表达列表，最好使用YAML格式。SpringBoot支持自动加载约定名称的配置文件，例如application.yml。如果是自定义名称的配置文件，就要另找方法了。可惜的是，不像前者有@PropertySource这样方便的加载方式，后者的加载必须借助编码逻辑来实现。 1.加载顺序 bootstrap.yml：用于程序引导时执行，应用于更加早期配置信息读取，用来配置application.yml中使用到参数等。 application.yml：应用程序特有配置信息，可以用来配置后续各个模块中需使用的公共参数等。 bootstrap.yml 先于 application.yml 加载，bootstrap.yml 由父Spring ApplicationContext加载。 2.配置区别 bootstrap.yml和application.yml 都可以用来配置参数。 bootstrap.yml 可以理解成系统级别的一些参数配置，这些参数一般是不会变动的。 application.yml 可以用来定义应用级别的，如搭配 spring-cloud-config 使用 application.yml 里面定义的文件可以实现动态替换。 使用Spring Cloud Config Server时，应在 bootstrap.yml 中指定常用信息： spring.application.name spring.cloud.config.server.git.uri 一些加密/解密信息 相关文章：SpringCloud配置文件 application.yml和 bootstrap.yml区别Spring Boot中application.yml与bootstrap.yml的区别 创建Config Client工程1. 在父工程的基础上创建一个Module子工程用作Config Client (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery、Web及Config Client依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 1234567891011server: port: 8001spring: application: name: itest-configeureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 增加bootstrap.yml配置文件并加入如下配置 123456spring: cloud: config: uri: http://localhost:8000/ label: master profile: dev 3. 修改相关代码并启动测试 (1) Step：在启动类上加入注解@EnableEurekaClient和@RestController并加入测试接口 (2) Step：先后启动itest-server，config-server，itest-config 三个工程后打开测试页面 测试地址：http://localhost:8001/msg (3) Step：修改bootstrap.yml中的profile为test后再次刷新上面的测试页面可以看到对应的信息 123456spring: cloud: config: uri: http://localhost:8000/ label: master profile: test (4) Step：修改本地application.yml加入msg测试本地配置覆盖远程配置 (5) Step：还需要修改远程配置（以application-test.yml为例）加入allowOverride: true（记得修改完要Push到Git远程仓库中） PS：默认情况下，本地的配置文件不能覆盖远程配置，但是可以通过启动命令行参数来覆盖远程配置。如果需要本地文件覆盖远程文件，需要在远程配置文件里设置授权spring.cloud.config.allowOverride=true（这个配置不能在本地被设置）。一旦设置了这个权限，你可以配置更加细粒度的配置来配置覆盖的方式，比如： ● spring.cloud.config.overrideNone=true 覆盖任何本地属性 ● spring.cloud.config.overrideSystemProperties=false 仅仅系统属性和环境变量 (6) Step：重启itest-config工程再次刷新上面的测试页面可以看到本地配置已覆盖远程配置 配置手动刷新项目一旦放到生产环境，就需要不停机更改配置。比如更改一些线程池连接数什么的，或者是配置文件，这里测试手动刷新Git仓库上的配置文件。 1. 修改itest-config相关代码 (1) Step：在项目pom文件中加入actuator依赖，就可以使用/refresh 这个节点来刷新带有@RefreshScope注解服务的Bean (2) Step：在启动类上加入注解@RefreshScope (3) Step：修改Git仓库中的application-dev.yml配置文件并Push到远程仓库 1msg: this is dev config modify 2018.07.10-01 (4) Step：手动刷新需要通过使用post方法去请求 http://localhost:8001/refresh 来调用refresh方法 但是返回404，说明此接口已请求不到，其原因主要还是SpringCloud版本的问题，在最新的版本中指出由于endpoints中会包含很多敏感信息，提示需要小心的暴露它们，这也是management.security.enabled=false被删除的原因。具体接口列表可查看此官方链接：Endpoints ，会发现除了health和info两个支持web访问外，其他的默认不支持web访问。 (5) Step：解决方法是在bootstrap.yml文件中添加下面的代码：management.endpoints.web.exposure.include=* 暴露全部endpoints，我们这里只暴露 refresh 接口 1234567891011121314151617 spring: cloud: config:# uri: http://localhost:8000/ label: master profile: dev discovery: enabled: true service-id: config-server#新版本新的配置方法: /actuator/refreshmanagement: endpoints: web: exposure: include: ["refresh"] 2. 重启itest-config进行测试 (1) Step：重新启动itest-config工程，再用Postman使用post方法请求 http://localhost:8001/actuator/refresh (2) Step：发送Post请求成功后，会发现控制台会打印类似重启的信息 (3) Step：重新修改Git仓库中的application-dev.yml配置文件并Push到远程仓库 1msg: this is dev config modify 2018.07.10-02 (4) Step：再用Postman使用Post方法请求 /actuator/refresh 打开上面的测试地址：http://localhost:8001/msg ，可以看到手动刷新已生效 高可用分布式配置中心在实际的生产环境中往往会有非常多的服务实例，都需要从配置中心读取文件，所以很有必要将配置中心进行集群化，从而达到高可用。 1. 改造itest-config工程 修改配置文件bootstrap.yml，加入集群配置相关信息： 12345678910 spring: cloud: config:# uri: http://localhost:8000/ label: master profile: dev discovery: enabled: true service-id: config-server 2. 重新启动工程进行测试 重新启动config-server:8000，config-server:8800，itest-config三个工程，其中包括config-server两个实例，打开：http://localhost:8761/ 可以看到如下页面 重新访问 http://localhost:8001/msg 可以看到如下页面，说明高可用的配置已经生效 源码下载：https://github.com/rocye/SpringCloudStudy 总结SpringCloudConfig就是我们通常意义上的配置中心，把应用原本放在本地文件的配置抽取出来放在中心服务器，从而能够提供更好的管理、发布能力。SpringCloudConfig分服务端和客户端，服务端负责将git svn中存储的配置文件发布成REST接口，客户端可以从服务端REST接口获取配置。但客户端并不能主动感知到配置的变化，从而主动去获取新的配置，这需要每个客户端通过POST方法触发各自的/refresh。手动刷新在实际的生产环境中仍然是很繁琐的，这时就需要用到另一个组件Bus了。 SpringCloudBus通过一个轻量级消息代理连接分布式系统的节点。这可以用于广播状态更改（如配置更改）或其他管理指令。SpringCloudBus提供了通过POST方法访问的endpoint/bus/refresh，这个接口通常由git的钩子功能调用，用以通知各个SpringCloudConfig的客户端去服务端更新配置。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#_spring_cloud_confighttps://www.w3cschool.cn/spring_cloud/spring_cloud-vca32ixm.htmlhttps://blog.csdn.net/forezp/article/details/70037291https://www.cnblogs.com/BlogNetSpace/p/8469033.htmlhttps://blog.csdn.net/jeikerxiao/article/details/78914132https://zhuanlan.zhihu.com/p/34784934https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>SpringCloudConfig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01、JAVA8新特性简介]]></title>
    <url>%2FJAVA8-001%2F</url>
    <content type="text"><![CDATA[速度更快我们应该知道JAVA8中最为核心是Lambda表达式和Stream API，除此之外JAVA8还在底层数据结构及内存结构等方面做了优化，目的都是为了让它速度更快。 ● 底层数据结构进行了优化- HashMap（HashSet同理）1) 在JAVA7中 HashMap = 数组 + 链表 ：不管我们将hashCode与equals方法写的多好，都有可能发生碰撞，碰撞是指hashCode相同但是key却不相同，些时会放在链表中。 2) 在JAVA8中 HashMap = 数组 + 链表 + 红黑树 ：通过加入红黑树优化后，除了添加操作外，其它的查找，删除，修改等效率都大大提升。即：当碰撞元素个数大于8并且总容量大于64时将会使链表转成红黑树。 相关文章：Java8系列之重新认识HashMapJava7/Java8中HashMap解析 - ConcurrentHashMap1) 在JAVA7中采用分段锁机制(默认16个段) ：JAVA7中通过并行级别参数（ConcurrentLevel=16）进行分段锁机制，提高并行效率。 2) 在JAVA8中不再采用锁机制而是改成CAS算法 相关文章：Java8—ConcurrentHashMap分析ConcurrentHashMap演进从Java7到Java8 ● 内存结构及垃圾回收机制进行了优化- JAVA7内存结构调优配置参数：PremGenSize 和 MaxPremGenSize - JAVA8内存结构调优配置参数：MetaSpaceSize 和 MaxMetaSpaceSize PS：使用了物理内存后垃圾回收机制效率都将得到提升，且OOM异常发生的概率也极低，因为项目的类结构文件占不了太大的空间。 相关文章：JAVA7、JAVA8的堆内存有啥变化Java8—底层内存结构方法区 ● 能更好的支持并行运算即并行流ParallelStream 代码更少增加了新的语法Lambda表达式 Stream API增加了强大的Stream API 便于并行增加了并行流ParallelStream 最大化减少空指针异常增加了Optional 相关文章：Java 8 Optional类深度解析使用 Java 8 Optional 的正确姿势 总结以上只是JAVA8新特性的简介。 PS：JAVA8新特性中最为核心的是Lambda表达式与Stream API]]></content>
      <categories>
        <category>JAVA8笔记</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08、Zuul - 路由网关]]></title>
    <url>%2FSpringCloud-008%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Eureka Version：2.0.0.RELEASE Zuul Version：2.0.0.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在前面的文章中我们已经介绍了好几个微服务架构中最基础的服务治理组件，包括服务注册与发现(Eureka)、服务消费及负载均衡(Ribbon&amp;Feign)和断路器(Hystrix&amp;Turbine)，接下来我们还会介绍路由网关及服务配置等。由于此系列笔记都是分开测试的各个组件，很难体会到各组件整体的概念，如果初学者有类似这样的模糊不清感觉，大家可以再回过头去看下此系列第一篇文章：从微服务框架到SpringCloud ，在这篇文章找到微服务化要点关联图，相信会对组件之间的关联有一个更深的理解。 Zuul简介Zuul是Netflix的基于JVM的路由器和服务器端负载均衡器，在云平台上提供动态路由，监控，弹性，安全等边缘服务的框架。路由功能：相当于 nginx 的反向代理功能，比如：/ 可能需要映射到你的 web 应用，/api/users 映射到用户服务，/api/shop 映射到商城服务。Zuul默认和Ribbon结合实现了负载均衡的功能。所包含的功能： Authentication：认证 Insights：洞察 Stress Testing：压力测试 Canary Testing：金丝雀测试 Dynamic Routing：动态路由 Service Migration：服务迁移 Load Shedding：负载脱落 Security：安全 Static Response handling：静态响应处理 Active/Active traffic management：主动/主动流量管理 创建Zuul服务网关1. 在父工程的基础上创建一个Module子工程用作Zuul服务网关 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery,Web及Zuul依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 1234567891011121314151617181920server: port: 8766spring: application: name: itest-zuuleureka: client: service-url: defaultZone: http://localhost:8761/eureka/zuul: routes: api-a: path: /api-a/** serviceId: itest-ribbon api-b: path: /api-b/** serviceId: itest-feign 3. 修改相关代码并启动测试 (1) Step：在启动类上加入注解@EnableEurekaClient和@EnableZuulProxy (2) Step：先后启动itest-server，itest-client，itest-ribbon, itest-order，itest-feign, itest-zuul 六个工程后打开: http://localhost:8761 可以看到如下页面 (3) Step：打开浏览器输入: http://localhost:8766/api-a/testRibbon?name=rocye 可以看到如下页面 (4) Setp：打开浏览器输入: http://localhost:8766/api-b/testFeign?name=fruit 可以看到如下页面 由此可见，Zuul的路由功能已经生效了。 自定义过滤器Zuul 不仅只是路由，可以自定义过滤器来实现服务验证。测试：自定义过滤器，校验头部是否带有 token，如果 token=MyToken 通过校验， 若不存在或者不为 MyToken 则返回提示 tonken 错误。 √ 在工程中加入自定义过滤器 1234567891011121314151617181920212223242526272829303132333435363738394041424344import com.netflix.zuul.ZuulFilter;import com.netflix.zuul.context.RequestContext;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import org.springframework.util.ReflectionUtils;import javax.servlet.http.HttpServletRequest;@Componentpublic class MyPreFilter extends ZuulFilter &#123; private static Logger logger = LoggerFactory.getLogger(MyPreFilter.class); public String filterType() &#123; return "pre"; &#125; public int filterOrder() &#123; return 0; &#125; public boolean shouldFilter() &#123; return true; &#125; public Object run() &#123; RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); logger.warn(String.format("%s &gt;&gt;&gt; %s", request.getMethod(), request.getRequestURL().toString())); Object accessToken = request.getParameter("token"); if(!"MyToken".equals(accessToken))&#123; ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); try &#123; ctx.getResponse().getWriter().write("token is empty or error !"); &#125; catch (Exception e) &#123; ReflectionUtils.rethrowRuntimeException(e); &#125; logger.warn("token error !"); &#125;else&#123; logger.warn("token success !"); &#125; return null; &#125;&#125; √ 自定义过滤器中的filterType类型 filterType：返回一个字符串代表过滤器的类型，在Zuul中定义了四种不同生命周期的过滤器类型，具体如下： pre：路由之前 routing：路由之时 post： 路由之后 error：发送错误调用 filterOrder：过滤的顺序。 shouldFilter：这里可以写逻辑判断，是否要过滤，本文true，永远过滤。 run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。 过滤器的生命周期： √ 重新启动itest-zuul工程测试 (1) Step：再次打开地址: http://localhost:8766/api-a/testRibbon?name=rocye 可以看到如下页面 因为没有带token所以提示错误，修改地址打开: http://localhost:8766/api-a/testRibbon?name=rocye&amp;token=MyToken 可以看到正确的结果 (2) Setp：再次打开地址: http://localhost:8766/api-b/testFeign?name=fruit 可以看到如下页面 同样提示错误，同样修改地址打开: http://localhost:8766/api-b/testFeign?name=fruit&amp;token=MyToken 也可以看到正确的结果 由此可见，自定义过滤器已经达到了预期的效果。 源码下载：https://github.com/rocye/SpringCloudStudy 总结路由网关Zuul组件所包含的内容及相关配置远不止本文所介绍的这些，本系列文章旨在入门，让初学者先有一个概念，先了解它的核心，以后的文章会慢慢进行深入探讨。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#_router_and_filter_zuulhttps://blog.csdn.net/dengqiang123456/article/details/76223526https://blog.csdn.net/dengqiang123456/article/details/76223537https://blog.csdn.net/forezp/article/details/69939114https://www.cnblogs.com/lexiaofei/p/7080257.htmlhttps://www.w3cschool.cn/spring_cloud/spring_cloud-pzs12ixk.html]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Zuul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07、Turbine - 断路器集群监控]]></title>
    <url>%2FSpringCloud-007%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Eureka Version：2.0.0.RELEASE Turbine Version：2.0.0.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在前面两篇文章中介绍了Hystrix监控单体应用，但是在生产环境中，我们要监控的应用往往是一个集群。而且在复杂的分布式系统中，相同服务的节点经常需要部署上百甚至上千个，很多时候，运维人员希望能够把相同服务的节点状态以一个整体集群的形式展现出来，这样可以更好的把握整个系统的状态。 为此，Netflix提供了一个开源项目（Turbine）来提供把多个hystrix.stream的内容聚合为一个数据源供Dashboard展示。 监控单个集群应用(默认名称)cluster-name-expression: new String(‘default’)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认集群名称 1. 在父工程的基础上创建一个Module子工程用作Turbine监控客户端 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery,Hystrix Dashboard及Turbine依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 123456789101112131415161718server: port: 9000spring: application: name: itest-turbineeureka: client: service-url: defaultZone: http://localhost:8761/eureka/turbine: app-config: itest-ribbon cluster-name-expression: new String('default')# aggregator:# cluster-config: default combine-host-port: true 配置说明：turbine.app-config：# 配置Eureka中的serviceId，这里表示只监测itest-ribbon这一个应用（或对应的集群）turbine.aggregator.cluster-config：# 指定聚合哪些集群，多个使用”,”分割，默认为defaultturbine.clusterNameExpression：# default表示默认集群名，当值为default时上面的cluster-config可以省略turbine.combine-host-port：# true表示同一主机上的服务通过host和port的组合来进行区分，默认情况下是使用host来区分的 3. 修改相关代码 在启动类上加入注解@EnableTurbine和@EnableHystrixDashboard用于开启Turbine及仪表盘功能 4. 启动项目进行测试 (1) Step：先后启动itest-server，itest-client，itest-ribbon:8764, itest-ribbon:8774, itest-turbine五个工程后打开: http://localhost:8761 可以看到如下页面 (2) Setp：但是控制台可能会出现如下异常 123456com.netflix.turbine.monitor.instance.InstanceMonitor$MisconfiguredHostException:[&#123;"timestamp":"2018-06-28T08:01:38.908+0000","status":404,"error":"Not Found","message":"No message available","path":"/actuator/hystrix.stream"&#125;]at com.netflix.turbine.monitor.instance.InstanceMonitor.init(InstanceMonitor.java:318) ~[turbine-core-1.0.0.jar:na]at com.netflix.turbine.monitor.instance.InstanceMonitor.access$100(InstanceMonitor.java:103) ~[turbine-core-1.0.0.jar:na]at com.netflix.turbine.monitor.instance.InstanceMonitor$2.call(InstanceMonitor.java:235) [turbine-core-1.0.0.jar:na]at com.netflix.turbine.monitor.instance.InstanceMonitor$2.call(InstanceMonitor.java:229) [turbine-core-1.0.0.jar:na] 原因是因为Turbine启动后无法找到 “/actuator/hystrix.stream” ，在前面文章 Hystrix - 断路器之在Ribbon中的使用 中我们所配置的路径是”/hystrix.stream”，所以这里会导致上面的 404 异常，解决办法是需要加入配置如下 (3) Setp：重启itest-turbine工程一切正常，打开 http://localhost:9000/hystrix 然后输入监控地址，因为前面我们使用的是default cluster所以这里输入：http://localhost:9000/turbine.stream (4) Setp：点击 Monitor Stream 按钮后，需要访问 http://localhost:8764/testRibbon?name=rocye 和 http://localhost:8774/testRibbon?name=rocye 可以多刷新几次，可以看到如下效果 从仪表盘页面显示可以看到 Hosts 为 2 表示集群数量，以上就是Turbine监控单个集群在仪表盘中的显示效果 5. 仪表盘上参数详细说明 在前面的文章中大概介绍过仪表盘上的参数，但不是很全，这里再补上一张更详细的注解图 监控多个集群应用(默认名称) cluster-name-expression: new String(‘default’)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认集群名称 1. 在父工程的基础上创建一个Module子工程用作另一个微服务测试应用 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery及Web依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 1234567891011server: port: 8763spring: application: name: itest-ordereureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 3. 修改相关代码 (1) Step：在启动类上加入注解@EnableEurekaClient (2) Step：创建OrderController类，对外提供服务 (3) Step：修改前面的工程itest-feign，让它调用itest-order提供的服务 123456789101112import org.springframework.cloud.openfeign.FeignClient;import org.springframework.stereotype.Service;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;@Service("feignService")@FeignClient(value = "itest-order",fallback = FeignServiceHystrix.class)public interface IFeignService &#123; @RequestMapping(value = "/order", method = RequestMethod.GET) String testFeign(@RequestParam(value = "name") String name);&#125; (4) Step：修改工程itest-turbine中的turbine配置加入新的集群itest-feign 1234567891011121314151617181920 server: port: 9000spring: application: name: itest-turbineeureka: client: service-url: defaultZone: http://localhost:8761/eureka/turbine: app-config: itest-ribbon,itest-feign cluster-name-expression: new String('default')# aggregator:# cluster-config: default combine-host-port: true instanceUrlSuffix: /hystrix.stream 4. 启动项目进行测试 (1) Step：先后启动itest-server, itest-client, itest-order, itest-ribbon:8764, itest-ribbon:8774, itest-feign:8765, itest-feign:8775, itest-turbine 八个工程后打开: http://localhost:8761 可以看到如下页面，其中itest-ribbon和itest-feign分别启动两个实例模拟两个集群服务 (2) Setp：重新打开 http://localhost:9000/hystrix 然后依然输入前面那个默认集群名(defalut)所用到的监控地址：http://localhost:9000/turbine.stream 点击 Monitor Stream 按钮后，需要访问下面四个地址，可以多刷新几次： http://localhost:8764/testRibbon?name=rocye ， http://localhost:8774/testRibbon?name=rocye http://localhost:8765/testFeign?name=fruit ， http://localhost:8775/testFeign?name=fruit 就能看到仪表盘中参数的变化，如下图中的效果 监控单个集群应用(指定名称) cluster-name-expression: new String(‘APPNAME’)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;监控单集群时可以省略 1. 修改itest-turbine工程的配置 这里修改为只监控itest-ribbon一个集群，集群名通过应用名指定 1234567891011121314151617181920server: port: 9000spring: application: name: itest-turbineeureka: client: service-url: defaultZone: http://localhost:8761/eureka/turbine: app-config: itest-ribbon# cluster-name-expression: new String('ITEST-RIBBON') aggregator: cluster-config: ITEST-RIBBON combine-host-port: true instanceUrlSuffix: /hystrix.stream 2. 启动项目进行测试 (1) Step：先后启动itest-server, itest-client, itest-ribbon:8764, itest-ribbon:8774, itest-turbine 五个工程后打开: http://localhost:8761 可以看到如下页面 (2) Setp：重新打开 http://localhost:9000/hystrix 然后输入新的监控地址：http://localhost:9000/turbine.stream?cluster=ITEST-RIBBON (3) Setp：点击 Monitor Stream 按钮后，需要访问 http://localhost:8764/testRibbon?name=rocye 和 http://localhost:8774/testRibbon?name=rocye 可以多刷新几次，就能看到如下效果 从结果可以看出此配置方式和上面的默认名称下的单个集群应用配置效果一样 监控多个集群应用(指定名称) cluster-name-expression: metadata[‘cluster’]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自定义集群名称 1. 修改工程配置文件 (1) Step：修改itest-turbine配置文件自定义集群名称监控多个集群应用 1234567891011121314151617181920server: port: 9000spring: application: name: itest-turbineeureka: client: service-url: defaultZone: http://localhost:8761/eureka/turbine: app-config: itest-ribbon,itest-feign cluster-name-expression: metadata['cluster'] aggregator: cluster-config: mycluster combine-host-port: true instanceUrlSuffix: /hystrix.stream (2) Step：修改itest-ribbon配置文件指定cluster 123456789101112131415server: port: 8764spring: application: name: itest-ribboneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: metadata-map: cluster: mycluster (3) Step：修改itest-feign配置文件指定cluster 12345678910111213141516171819server: port: 8765spring: application: name: itest-feigneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: metadata-map: cluster: myclusterfeign: hystrix: enabled: true 2. 启动项目进行测试 (1) Step：先后启动itest-server, itest-client, itest-order, itest-ribbon:8764, itest-ribbon:8774, itest-feign:8765, itest-feign:8775, itest-turbine 八个工程后打开: http://localhost:8761 可以看到如下页面，其中itest-ribbon和itest-feign分别启动两个实例模拟两个集群服务 (2) Setp：重新打开 http://localhost:9000/hystrix 然后输入新的监控地址：http://localhost:9000/turbine.stream?cluster=mycluster 点击 Monitor Stream 按钮后，需要访问下面四个地址，可以多刷新几次： http://localhost:8764/testRibbon?name=rocye ， http://localhost:8774/testRibbon?name=rocye http://localhost:8765/testFeign?name=fruit ， http://localhost:8775/testFeign?name=fruit 就能看到仪表盘中参数的变化，如下图中的效果 源码下载：https://github.com/rocye/SpringCloudStudy 总结本文是根据cluster-name-expression参数的不同值进行了详细测试，主要是因为在网上找到的一些博客只是对参数进行了说明，没有代码示例，仍然觉得云里雾里，所以干脆把这几种情况都测试了一下，篇服较大，图片较多，但是根据最终的效果应该能清楚区分此参数不同值之间的区别。 参考文章：https://blog.csdn.net/u012702547/article/details/78224483http://www.ityouknow.com/springcloud/2017/05/18/hystrix-dashboard-turbine.htmlhttps://blog.csdn.net/dengqiang123456/article/details/76223521https://blog.csdn.net/forezp/article/details/70233227]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Hystrix</tag>
        <tag>Turbine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06、Hystrix - 断路器之在Feign中的使用]]></title>
    <url>%2FSpringCloud-006%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Eureka Version：2.0.0.RELEASE Feign Version：2.0.0.RELEASE Hystrix Version：1.4.4.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在上一篇的文章中已经介绍了Hystrix在Ribbon中的使用，我们知道Ribbon和Feign所完成的功能都是服务消费，本篇文章将会介绍Hystrix断路器在Feign中的使用。 修改itest-feign工程加入断路器1. 不需要修改pom文件 如果只是开启Feign的断路器功能不需要在pom文件中额外加入hystrix依赖 2. 修改相关代码 (1) Step：添加断路器回调方法，实现先前接口IFeignService新建回调类：FeignServiceHystrix (2) Step：然后修改接口IFeignService指定回调类 (3) Step：最后还需要修改application.yml开启断路器功能 3. 启动项目进行测试 (1) Step：先后启动itest-server，itest-client，itest-feign三个工程后打开: http://localhost:8761 可以看到如下页面 (2) Setp：打开浏览器输入: http://localhost:8765/testFeign?name=rocye 可以看到如下页面 (3) Setp：接下来关闭itest-client工程，查看断路器是否生效（需要等几秒刷新上面的页面） 由此可见，断路器已经生效了。 4. 加入Hystrix Dashboard (断路器仪表盘) (1) Step：在pom文件中加入hystrix dashboard依赖 12345678910111213141516&lt;!-- 2.加入断路器仪表盘功能 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt; (2) Setp：在启动类上加入注解@EnableHystrixDashboard用于开启断路器仪表盘功能，同时加入hystrix.stream的Servlet (3) Setp：重启itest-feign工程，打开: http://localhost:8765/hystrix 页面 (4) Setp：然后输入监测地址：http://localhost:8765/hystrix.stream 点击“Moniter Stream”，接下来可以在浏览器中打开: http://localhost:8765/testFeign?name=rocye 多刷新几次可以看到监测的效果如下所示 源码下载：https://github.com/rocye/SpringCloudStudy 总结Feign底层整合了Ribbon，两者相比较而言，声明式的Feign用起来更方便。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_clientshttps://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_dashboardhttps://blog.csdn.net/forezp/article/details/69934399https://blog.csdn.net/yejingtao703/article/details/77683102]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Feign</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05、Hystrix - 断路器之在Ribbon中的使用]]></title>
    <url>%2FSpringCloud-005%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Eureka Version：2.0.0.RELEASE Ribbon Version：2.0.0.RELEASE Hystrix Version：1.4.4.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud中可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是常说的“雪崩”效应。为了解决这个问题，业界提出了断路器模型。 断路器简介Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图：较底层的服务如果出现故障，会导致连锁故障。当对特定服务的调用不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。 修改itest-ribbon工程加入断路器1. 修改工程pom.xml文件 在pom文件中加入hystrix依赖 123456&lt;!-- 2.加入断路器功能 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt; 2. 修改相关代码 (1) Step：在启动类上加入注解@EnableHystrixet用于开启断路器功能 (2) Step：然后在测试类TestService对应的接口方法加入注解@HystrixCommand 定义断路器回调方法 123public String testError(String name) &#123; return "hello " + name + ", happen error!";&#125; 3. 启动项目进行测试 (1) Step：先后启动itest-server，itest-client，itest-ribbon三个工程后打开: http://localhost:8761 可以看到如下页面 (2) Setp：打开浏览器输入: http://localhost:8764/testRibbon?name=rocye 可以看到如下页面 (3) Setp：接下来关闭itest-client工程，查看断路器是否生效（需要等几秒刷新上面的页面） 由此可见，断路器已经生效了。 4. 加入Hystrix Dashboard (断路器仪表盘) (1) Step：在pom文件中加入hystrix dashboard依赖 1234567891011&lt;!-- 3.加入断路器仪表盘功能 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt; PS：手动修改POM文件后，如果发现依赖没生效，可以Reimport解决，如下所示 刷新完后看到最终的依赖如下所示 (2) Setp：在启动类上加入注解@EnableHystrixDashboard用于开启断路器仪表盘功能 (3) Setp：重启itest-ribbon工程，打开: http://localhost:8764/hystrix 页面 然后输入监测地址：http://localhost:8764/hystrix.stream 点击“Moniter Stream” 但是无法正常显示数据而是显示：Unable to connect to Command Metric Stream. 查看日志发现报 404 错误，是因为hystrix.stream地址找不到 (4) Setp：解决办法是需要加入hystrix.stream的Servlet 12345678910//断路器仪表盘功能(解决hystrix.stream : 404 : HTTP/1.1 404 )@Beanpublic ServletRegistrationBean getServlet()&#123; HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings("/hystrix.stream"); registrationBean.setName("HystrixMetricsStreamServlet"); return registrationBean;&#125; (5) Setp：然后重启itest-ribbon工程，再次打开: http://localhost:8764/hystrix 页面输入: http://localhost:8764/hystrix.stream 点击按钮就不再报上面的错了，接下来可以在浏览器中打开: http://localhost:8764/testRibbon?name=rocye 多刷新几次可以看到监测的效果如下所示 PS：实心圆：颜色代表健康度（绿-黄-红-橙递减），大小代表并发量；曲线：请求量的变化；其他主要参数如下图红色字体部分： 源码下载：https://github.com/rocye/SpringCloudStudy 总结以上是单结点服务的统计，相对简单，但是生产上为了服务的健壮性都是多结点，当被监控的服务变成了多个，在Dashboard之前需要一个收集器Turbine，此组件以后再专门介绍。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_clientshttps://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_dashboardhttps://blog.csdn.net/forezp/article/details/69934399https://blog.csdn.net/yejingtao703/article/details/77683102]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Ribbon</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04、Feign - 声明式REST客户端]]></title>
    <url>%2FSpringCloud-004%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在上一篇文章中，我们介绍了通过RestTemplate和Ribbon的服务调用及负载均衡的使用，在Spring Cloud中服务之间通过restful方式调用除了前面介绍的Ribbon外还有一种即是本篇要介绍的Feign。 Feign简介Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。 创建Feign客户端1. 在父工程的基础上创建一个Module子工程用作Ribbon负载均衡器 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery,Web及Feign依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 1234567891011server: port: 8765spring: application: name: itest-feigneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 3. 修改相关代码 (1) Step：在启动类上加入注解@EnableEurekaClient和@EnableFeignClients (2) Step：创建feign接口，通过@FeignClient(“服务名”)，来指定调用哪个服务及具体的接口 (3) Step：创建TestController类用于调用IFeignService进行测试 注：这里注入IFeignService接口时可能会在某些IDE中报语法错，可以在上面的接口中加入@Service注解解决些问题 4. 启动项目进行测试 (1) Step：先启动Eureka服务端itest-server，然后修改启动配置，先启动itest-client端口8762，再启动itest-client端口8763 打开: http://localhost:8761 可以看到itest-client两个实例 (2) Setp：最后启动Feign客户端，刷新上面的页面可以看到itest-feign实例 最终我们启动了如下四个实例 (3) Setp：打开浏览器输入: http://localhost:8765/testFeign?name=rocye 多刷新几次页面可以看到8762和8763端口交替出现 由此可见，已经达到了负载均衡的效果。 源码下载：https://github.com/rocye/SpringCloudStudy 总结 服务注册中心：itest-server 端口为8761 两个测试用的服务实例：itest-client 端口为8762和8763，都注册到了Eureka服务端 服务消费实例(即负载均衡器)：itest-feign端口为8765，也注册到了Eureka服务端 从实践上看，采用feign的方式更优雅，而且feign内部也使用了ribbon做负载均衡 参考文章：https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-feignhttps://blog.csdn.net/forezp/article/details/69808079https://blog.csdn.net/jrn1012/article/details/77837658]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03、Ribbon - 客户端负载均衡器]]></title>
    <url>%2FSpringCloud-003%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在上一篇文章中，我们介绍了使用Eureka作为服务注册中心，在服务启动后，各个微服务会将自己注册到Eureka server。那么服务之间是如何调用？又是如何进行负载均衡的？本文将介绍服务的调用及负载均衡器Ribbon的使用。 创建Ribbon负载均衡器1. 在父工程的基础上创建一个Module子工程用作Ribbon负载均衡器 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery,Web及Ribbon依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 1234567891011server: port: 8764spring: application: name: itest-ribboneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 3. 修改相关代码 (1) Step：在启动类上加入注解@EnableEurekaClient，再通过@Bean注入restTemplate，并通过@LoadBalanced开启负载均衡 (2) Step：创建测试类TestService并注入restTemplate，用来调用itest-client服务的”/test”接口 (3) Step：创建TestController类用于调用TestService进行测试 4. 启动项目进行测试 (1) Step：先启动Eureka服务端itest-server，然后修改启动配置，先启动itest-client端口8762，再启动itest-client端口8763 打开: http://localhost:8761 可以看到itest-client两个实例 (2) Setp：最后启动ribbon负载均衡器，刷新上面的页面可以看到itest-ribbon实例 最终我们启动了如下四个实例 (3) Setp：打开浏览器输入: http://localhost:8764/testRibbon?name=rocye 多刷新几次页面可以看到8762和8763端口交替出现 由此可见，已经达到了负载均衡的效果。 源码下载：https://github.com/rocye/SpringCloudStudy 总结 服务注册中心：itest-server 端口为8761 两个测试用的服务实例：itest-client 端口为8762和8763，都注册到了Eureka服务端 服务消费实例(即负载均衡器)：itest-ribbon 端口为8764，也注册到了Eureka服务端 Ribbon是对服务之间调用做负载，是服务之间的负载均衡，Zuul是可以对外部请求做负载均衡 PS：Zuul的负载均衡功能是针对外部请求做负载。客户端ribbon的负载均衡，解决的是服务发起方（在Eureka注册的服务）对被调用的服务的负载，比如我们查询商品服务要调用显示库存和商品明细服务，通过商品服务的接口将两个服务组合，可以减少外部应用的请求。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-ribbonhttps://blog.csdn.net/forezp/article/details/69788938https://blog.csdn.net/jrn1012/article/details/77837658]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02、Eureka - 服务的注册与发现]]></title>
    <url>%2FSpringCloud-002%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Sping Boot Version：2.0.3.RELEASE 创建Eureka服务器 (eureka server)1. 创建一个Maven主工程 (1) Step：这里不勾选“Create from archetype” (2) Step：自定义GroupId和ArtifactId (3) Step：自定义工程名及路径 (4) Step：创建完成后如下图，因为是空的父工程所以可以将src文件夹删除 2. 在父工程的基础上创建一个Module子工程用作Eureka服务器 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里只需要选择Eureka服务端依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 3. 修改工程配置文件类型为YML并加入配置 (1) Step：修改application.properties为application.yml（注：本工程配置文件将全部采用YML格式） (2) Step：在配置文件中加入如下配置，其中将registerWithEureka和fetchRegistry设置为false标识此为服务端 1234567891011server: port: 8761eureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 4. 在启动类上加入注解@EnableEurekaServer 启动itest-server工程，在浏览器中打开：http://localhost:8761 看到下图所示页面表示Eureka服务端已创建成功 创建Eureka客户端 (eureka client)1. 在父工程的基础上创建一个Module子工程用作Eureka客户端 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery和Web依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置，其中service-url(或serviceUrl)配置成服务端地址 1234567891011server: port: 8762spring: application: name: itest-clienteureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 3. 在启动类上加入注解@EnableEurekaClient 4. 依次启动itest-server和itest-client工程，打开：http://localhost:8761 看到下图所示页面表示Eureka节点已创建成功 PS：测试Eureka节点关闭被服务端踢出需要正常退出，不能强制关闭，如下图 5. 创建测试的RestController(上面加入的Web依赖在这里用到) 6. 重启itest-client工程，在浏览器中打开：http://localhost:8762/test?name=rocye 看到下图所示页面 源码下载：https://github.com/rocye/SpringCloudStudy 总结基于IntelliJ IDEA开发工具构建Spring Cloud工程非常简单和方便，合理利用配置步骤中的选择来生成配置文件能减少不必要的错误。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-eureka-serverhttps://springcloud.cc/spring-cloud-dalston.html#_service_discovery_eureka_clientshttps://blog.csdn.net/forezp/article/details/69696915]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01、从微服务框架到SpringCloud]]></title>
    <url>%2FSpringCloud-001%2F</url>
    <content type="text"><![CDATA[什么是微服务框架对于微服务基础框架可以看作是微服务治理架构的核心内容，包括了对微服务模块的全生命周期管理能力，这个能力包括了微服务网关APP，DevOps，Docker和云集成，安全，负载均衡，服务注册和发现等诸多能力。微服务基础框架确实不是简单的微服务网关，而是对整个微服务基础环境的支撑和管控。 Netflix的微服务框架Netflix是一家成功实践微服务架构的互联网公司，几年前，Netflix把几乎整个微服务框架栈开源贡献给了社区，这些框架和组件包括： Eureka：服务注册发现框架 Zuul：服务网关 Karyon：服务端框架 Ribbon：客户端框架 Hystrix：服务容错组件 Archaius：服务配置组件 Servo：Metrics组件 Blitz4j：日志组件 下图展示了基于这些组件构建的一个微服务框架体系： Netflix的开源框架组件已经在Netflix的大规模分布式微服务环境中经过多年的生产实战验证，正逐步被社区接受为构造微服务框架的标准组件。Pivotal去年推出的Spring Cloud开源产品，主要是基于对Netflix开源组件的进一步封装，方便Spring开发人员构建微服务基础框架。 微服务化要点关联图了解了Netflix的微服务框架核心组件之后，我们很有必要总览一下这些组件之间的关系，这样更有利于对整个微服务框架的理解，接下来借用网易云的一张架构图，就能很清晰的了解这些组件之间的关系了： Spring CloudSpring Cloud正是对Netflix的多个开源组件进一步的封装而成，同时又实现了和云端平台及Spring Boot开发框架很好的集成。Spring Cloud 为开发者提供了在分布式系统（配置管理，服务发现，熔断，路由，微代理，控制总线，一次性token，全局锁，leader选举，分布式session，集群状态等等）中快速构建的工具，使用Spring Cloud的开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。 Spring Cloud Netflix，该项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路有（Zuul），客户端负载均衡（Ribbon）等。 当然Spring Cloud还有额外扩展的其它很多组件，包括了服务链路监控和跟踪（很关键的一个功能），消息总线，数据流处理，批量任务处理等。而对于整个Spring Cloud微服务框架简单来说，即是：你只要划分到你的微服务组件和模块，并定义好需要暴露的API接口，那么剩下的整个开发和传统方式没有太大的区别，你开发完成的组件集成起来就是一个分布式可扩展的微服务环境。里面设计到的接口发布，服务注册，服务调用和路由，服务监控，健康检测和流控等都会由微服务框架来帮你完成。 PS：正是有了成熟的微服务框架，我们才更应该将微服务架构设计重心从技术底层转移到组件划分和接口设计上。 Spring Cloud VS DubboR1：背景Dubbo：是阿里巴巴服务化治理的核心框架，并被广泛应用于阿里巴巴集团的各成员站点。 Spring Cloud：是Spring Source的产物，Spring社区的强大背书可以说是Java企业界最有影响力的组织了，除了Spring Source之外，还有Pivotal和Netfix是其强大的后盾与技术输出。其中Netflix开源的整套微服务架构套件是Spring Cloud的核心。 R2：社区活跃度我们选择一个开源框架，社区的活跃度是我们极为关注的一个要点。社区越活跃，解决问题的速度越快，框架也会越来越完善，不然当我们碰到问题，就不得不自己解决。而对于团队来说，也就意味着我们不得不自己去维护框架的源码，这对于团队来说也将会是一个很大的负担。 Dubbo ：https://github.com/dubbo Spring Cloud ：https://github.com/spring-cloud 小结：在社区活跃度上，Spring Cloud毋庸置疑的优于Dubbo，这对于没有大量精力与财力维护这部分开源内容的团队来说，Spring Cloud会是更优的选择。 R3：架构完整度根据微服务架构在各方面的要素，看看Spring Cloud和Dubbo都提供了哪些支持： Dubbo Spring Cloud 服务注册中心 Zookeeper Spring Cloud Netflix Eureka 服务调用方式 RPC REST API 服务网关 无 Spring Cloud Netflix Zuul 断路器 不完善 Spring Cloud Netflix Hystrix 分布式配置 无 Spring Cloud Config 服务跟踪 无 Spring Cloud Sleuth 消息总线 无 Spring Cloud Bus 数据流 无 Spring Cloud Stream 批量任务 无 Spring Cloud Task …… …… …… Dubbo对于上表中总结为“无”的组件不代表不能实现，而只是Dubbo框架自身不提供，需要另外整合以实现对应的功能，比如： 分布式配置：可以使用淘宝的diamond、百度的disconf来实现分布式配置管理。但是Spring Cloud中的Config组件除了提供配置管理之外，由于其存储可以使用git，因此它天然的实现了配置内容的版本管理，可以完美的与应用版本管理整合起来。服务跟踪：可以使用京东开源的Hydra批量任务：可以使用当当开源的Elastic-Job…… R4：对比总结通过上面几个环节上的分析，打个不恰当的比喻：使用Dubbo构建的微服务架构就像组装电脑，各环节我们的选择自由度很高，但是最终结果很有可能因为一条内存质量不行就点不亮了，总是让人不怎么放心，但是如果你是一名高手，那这些都不是问题；而Spring Cloud就像品牌机，在Spring Source的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性，但是如果要在使用非原装组件外的东西，就需要对其基础有足够的了解。 参考文章：http://blog.sina.com.cn/s/blog_493a84550102wkna.htmlhttp://blog.sina.com.cn/s/blog_493a84550102wkp2.htmlhttp://blog.didispace.com/microservice-framework/]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务框架</tag>
      </tags>
  </entry>
</search>
