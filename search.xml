<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[08、Zuul - 路由网关]]></title>
    <url>%2FSpringCloud-008%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Eureka Version：2.0.0.RELEASE Zuul Version：2.0.0.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在前面的文章中我们已经介绍了好几个微服务架构中最基础的服务治理组件，包括服务注册与发现(Eureka)、服务消费及负载均衡(Ribbon&amp;Feign)和断路器(Hystrix&amp;Turbine)，接下来我们还会介绍路由网关及服务配置等。由于此系列笔记都是分开测试的各个组件，很难体会到各组件整体的概念，如果初学者有类似这样的模糊不清感觉，大家可以再回过头去看下此系列第一篇文章：从微服务框架到SpringCloud ，在这篇文章找到微服务化要点关联图，相信会对组件之间的关联有一个更深的理解。 Zuul简介Zuul是Netflix的基于JVM的路由器和服务器端负载均衡器，在云平台上提供动态路由，监控，弹性，安全等边缘服务的框架。路由功能：相当于 nginx 的反向代理功能，比如：/ 可能需要映射到你的 web 应用，/api/users 映射到用户服务，/api/shop 映射到商城服务。Zuul默认和Ribbon结合实现了负载均衡的功能。所包含的功能： Authentication Insights Stress Testing Canary Testing Dynamic Routing Service Migration Load Shedding Security Static Response handling Active/Active traffic management 创建Zuul服务网关1. 在父工程的基础上创建一个Module子工程用作Zuul服务网关 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery,Web及Zuul依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 1234567891011121314151617181920server: port: 8766spring: application: name: itest-zuuleureka: client: service-url: defaultZone: http://localhost:8761/eureka/zuul: routes: api-a: path: /api-a/** serviceId: itest-ribbon api-b: path: /api-b/** serviceId: itest-feign 3. 修改相关代码并启动测试 (1) Step：在启动类上加入注解@EnableEurekaClient和@EnableZuulProxy (2) Step：先后启动itest-server，itest-client，itest-ribbon, itest-order，itest-feign, itest-zuul 六个工程后打开: http://localhost:8761 可以看到如下页面 (3) Step：打开浏览器输入: http://localhost:8766/api-a/testRibbon?name=rocye 可以看到如下页面 (4) Setp：打开浏览器输入: http://localhost:8766/api-b/testFeign?name=fruit 可以看到如下页面 由此可见，Zuul的路由功能已经生效了。 自定义过滤器Zuul 不仅只是路由，可以自定义过滤器来实现服务验证。测试：自定义过滤器，校验头部是否带有 token，如果 token=MyToken 通过校验， 若不存在或者不为 MyToken 则返回提示 tonken 错误。 √ 在工程中加入自定义过滤器 1234567891011121314151617181920212223242526272829303132333435363738394041424344import com.netflix.zuul.ZuulFilter;import com.netflix.zuul.context.RequestContext;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import org.springframework.util.ReflectionUtils;import javax.servlet.http.HttpServletRequest;@Componentpublic class MyPreFilter extends ZuulFilter &#123; private static Logger logger = LoggerFactory.getLogger(MyPreFilter.class); public String filterType() &#123; return "pre"; &#125; public int filterOrder() &#123; return 0; &#125; public boolean shouldFilter() &#123; return true; &#125; public Object run() &#123; RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); logger.warn(String.format("%s &gt;&gt;&gt; %s", request.getMethod(), request.getRequestURL().toString())); Object accessToken = request.getParameter("token"); if(!"MyToken".equals(accessToken))&#123; ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); try &#123; ctx.getResponse().getWriter().write("token is empty or error !"); &#125; catch (Exception e) &#123; ReflectionUtils.rethrowRuntimeException(e); &#125; logger.warn("token error !"); &#125;else&#123; logger.warn("token success !"); &#125; return null; &#125;&#125; √ 自定义过滤器中的filterType类型 filterType：返回一个字符串代表过滤器的类型，在Zuul中定义了四种不同生命周期的过滤器类型，具体如下： pre：路由之前 routing：路由之时 post： 路由之后 error：发送错误调用 filterOrder：过滤的顺序。 shouldFilter：这里可以写逻辑判断，是否要过滤，本文true，永远过滤。 run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。 过滤器的生命周期： √ 重新启动itest-zuul工程测试 (1) Step：再次打开地址: http://localhost:8766/api-a/testRibbon?name=rocye 可以看到如下页面 因为没有带token所以提示错误，修改地址打开: http://localhost:8766/api-a/testRibbon?name=rocye&amp;token=MyToken 可以看到正确的结果 (2) Setp：再次打开地址: http://localhost:8766/api-b/testFeign?name=fruit 可以看到如下页面 同样提示错误，同样修改地址打开: http://localhost:8766/api-b/testFeign?name=fruit&amp;token=MyToken 也可以看到正确的结果 由此可见，自定义过滤器已经达到了预期的效果。 源码下载：https://github.com/rocye/SpringCloudStudy 总结路由网关Zuul组件所包含的内容及相关配置远不止本文所介绍的这些，本系列文章旨在入门，让初学者先有一个概念，先了解它的核心，以后的文章会慢慢进行深入探讨。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#_router_and_filter_zuulhttps://blog.csdn.net/dengqiang123456/article/details/76223526https://blog.csdn.net/dengqiang123456/article/details/76223537https://blog.csdn.net/forezp/article/details/69939114]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Zuul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07、Turbine - 断路器集群监控]]></title>
    <url>%2FSpringCloud-007%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Eureka Version：2.0.0.RELEASE Turbine Version：2.0.0.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在前面两篇文章中介绍了Hystrix监控单体应用，但是在生产环境中，我们要监控的应用往往是一个集群。而且在复杂的分布式系统中，相同服务的节点经常需要部署上百甚至上千个，很多时候，运维人员希望能够把相同服务的节点状态以一个整体集群的形式展现出来，这样可以更好的把握整个系统的状态。 为此，Netflix提供了一个开源项目（Turbine）来提供把多个hystrix.stream的内容聚合为一个数据源供Dashboard展示。 监控单个集群应用(默认名称)cluster-name-expression: new String(‘default’)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认集群名称 1. 在父工程的基础上创建一个Module子工程用作Turbine监控客户端 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery,Hystrix Dashboard及Turbine依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 123456789101112131415161718server: port: 9000spring: application: name: itest-turbineeureka: client: service-url: defaultZone: http://localhost:8761/eureka/turbine: app-config: itest-ribbon cluster-name-expression: new String('default')# aggregator:# cluster-config: default combine-host-port: true 配置说明：turbine.app-config：# 配置Eureka中的serviceId，这里表示只监测itest-ribbon这一个应用（或对应的集群）turbine.aggregator.cluster-config：# 指定聚合哪些集群，多个使用”,”分割，默认为defaultturbine.clusterNameExpression：# default表示默认集群名，当值为default时上面的cluster-config可以省略turbine.combine-host-port：# true表示同一主机上的服务通过host和port的组合来进行区分，默认情况下是使用host来区分的 3. 修改相关代码 在启动类上加入注解@EnableTurbine和@EnableHystrixDashboard用于开启Turbine及仪表盘功能 4. 启动项目进行测试 (1) Step：先后启动itest-server，itest-client，itest-ribbon:8764, itest-ribbon:8774, itest-turbine五个工程后打开: http://localhost:8761 可以看到如下页面 (2) Setp：但是控制台可能会出现如下异常 123456com.netflix.turbine.monitor.instance.InstanceMonitor$MisconfiguredHostException:[&#123;"timestamp":"2018-06-28T08:01:38.908+0000","status":404,"error":"Not Found","message":"No message available","path":"/actuator/hystrix.stream"&#125;]at com.netflix.turbine.monitor.instance.InstanceMonitor.init(InstanceMonitor.java:318) ~[turbine-core-1.0.0.jar:na]at com.netflix.turbine.monitor.instance.InstanceMonitor.access$100(InstanceMonitor.java:103) ~[turbine-core-1.0.0.jar:na]at com.netflix.turbine.monitor.instance.InstanceMonitor$2.call(InstanceMonitor.java:235) [turbine-core-1.0.0.jar:na]at com.netflix.turbine.monitor.instance.InstanceMonitor$2.call(InstanceMonitor.java:229) [turbine-core-1.0.0.jar:na] 原因是因为Turbine启动后无法找到 “/actuator/hystrix.stream” ，在前面文章 Hystrix - 断路器之在Ribbon中的使用 中我们所配置的路径是”/hystrix.stream”，所以这里会导致上面的 404 异常，解决办法是需要加入配置如下 (3) Setp：重启itest-turbine工程一切正常，打开 http://localhost:9000/hystrix 然后输入监控地址，因为前面我们使用的是default cluster所以这里输入：http://localhost:9000/turbine.stream (4) Setp：点击 Monitor Stream 按钮后，需要访问 http://localhost:8764/testRibbon?name=rocye 和 http://localhost:8774/testRibbon?name=rocye 可以多刷新几次，可以看到如下效果 从仪表盘页面显示可以看到 Hosts 为 2 表示集群数量，以上就是Turbine监控单个集群在仪表盘中的显示效果 5. 仪表盘上参数详细说明 在前面的文章中大概介绍过仪表盘上的参数，但不是很全，这里再补上一张更详细的注解图 监控多个集群应用(默认名称) cluster-name-expression: new String(‘default’)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认集群名称 1. 在父工程的基础上创建一个Module子工程用作另一个微服务测试应用 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery及Web依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 1234567891011server: port: 8763spring: application: name: itest-ordereureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 3. 修改相关代码 (1) Step：在启动类上加入注解@EnableEurekaClient (2) Step：创建OrderController类，对外提供服务 (3) Step：修改前面的工程itest-feign，让它调用itest-order提供的服务 123456789101112import org.springframework.cloud.openfeign.FeignClient;import org.springframework.stereotype.Service;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;@Service("feignService")@FeignClient(value = "itest-order",fallback = FeignServiceHystrix.class)public interface IFeignService &#123; @RequestMapping(value = "/order", method = RequestMethod.GET) String testFeign(@RequestParam(value = "name") String name);&#125; (4) Step：修改工程itest-turbine中的turbine配置加入新的集群itest-feign 1234567891011121314151617181920 server: port: 9000spring: application: name: itest-turbineeureka: client: service-url: defaultZone: http://localhost:8761/eureka/turbine: app-config: itest-ribbon,itest-feign cluster-name-expression: new String('default')# aggregator:# cluster-config: default combine-host-port: true instanceUrlSuffix: /hystrix.stream 4. 启动项目进行测试 (1) Step：先后启动itest-server, itest-client, itest-order, itest-ribbon:8764, itest-ribbon:8774, itest-feign:8765, itest-feign:8775, itest-turbine 八个工程后打开: http://localhost:8761 可以看到如下页面，其中itest-ribbon和itest-feign分别启动两个实例模拟两个集群服务 (2) Setp：重新打开 http://localhost:9000/hystrix 然后依然输入前面那个默认集群名(defalut)所用到的监控地址：http://localhost:9000/turbine.stream 点击 Monitor Stream 按钮后，需要访问下面四个地址，可以多刷新几次： http://localhost:8764/testRibbon?name=rocye ， http://localhost:8774/testRibbon?name=rocye http://localhost:8765/testFeign?name=fruit ， http://localhost:8775/testFeign?name=fruit 就能看到仪表盘中参数的变化，如下图中的效果 监控单个集群应用(指定名称) cluster-name-expression: new String(‘APPNAME’)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;监控单集群时可以省略 1. 修改itest-turbine工程的配置 这里修改为只监控itest-ribbon一个集群，集群名通过应用名指定 1234567891011121314151617181920server: port: 9000spring: application: name: itest-turbineeureka: client: service-url: defaultZone: http://localhost:8761/eureka/turbine: app-config: itest-ribbon# cluster-name-expression: new String('ITEST-RIBBON') aggregator: cluster-config: ITEST-RIBBON combine-host-port: true instanceUrlSuffix: /hystrix.stream 2. 启动项目进行测试 (1) Step：先后启动itest-server, itest-client, itest-ribbon:8764, itest-ribbon:8774, itest-turbine 五个工程后打开: http://localhost:8761 可以看到如下页面 (2) Setp：重新打开 http://localhost:9000/hystrix 然后输入新的监控地址：http://localhost:9000/turbine.stream?cluster=ITEST-RIBBON (3) Setp：点击 Monitor Stream 按钮后，需要访问 http://localhost:8764/testRibbon?name=rocye 和 http://localhost:8774/testRibbon?name=rocye 可以多刷新几次，就能看到如下效果 从结果可以看出此配置方式和上面的默认名称下的单个集群应用配置效果一样 监控多个集群应用(指定名称) cluster-name-expression: metadata[‘cluster’]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自定义集群名称 1. 修改工程配置文件 (1) Step：修改itest-turbine配置文件自定义集群名称监控多个集群应用 1234567891011121314151617181920server: port: 9000spring: application: name: itest-turbineeureka: client: service-url: defaultZone: http://localhost:8761/eureka/turbine: app-config: itest-ribbon,itest-feign cluster-name-expression: metadata['cluster'] aggregator: cluster-config: mycluster combine-host-port: true instanceUrlSuffix: /hystrix.stream (2) Step：修改itest-ribbon配置文件指定cluster 123456789101112131415server: port: 8764spring: application: name: itest-ribboneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: metadata-map: cluster: mycluster (3) Step：修改itest-feign配置文件指定cluster 12345678910111213141516171819server: port: 8765spring: application: name: itest-feigneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: metadata-map: cluster: myclusterfeign: hystrix: enabled: true 2. 启动项目进行测试 (1) Step：先后启动itest-server, itest-client, itest-order, itest-ribbon:8764, itest-ribbon:8774, itest-feign:8765, itest-feign:8775, itest-turbine 八个工程后打开: http://localhost:8761 可以看到如下页面，其中itest-ribbon和itest-feign分别启动两个实例模拟两个集群服务 (2) Setp：重新打开 http://localhost:9000/hystrix 然后输入新的监控地址：http://localhost:9000/turbine.stream?cluster=mycluster 点击 Monitor Stream 按钮后，需要访问下面四个地址，可以多刷新几次： http://localhost:8764/testRibbon?name=rocye ， http://localhost:8774/testRibbon?name=rocye http://localhost:8765/testFeign?name=fruit ， http://localhost:8775/testFeign?name=fruit 就能看到仪表盘中参数的变化，如下图中的效果 源码下载：https://github.com/rocye/SpringCloudStudy 总结本文是根据cluster-name-expression参数的不同值进行了详细测试，主要是因为在网上找到的一些博客只是对参数进行了说明，没有代码示例，仍然觉得云里雾里，所以干脆把这几种情况都测试了一下，篇服较大，图片较多，但是根据最终的效果应该能清楚区分此参数不同值之间的区别。 参考文章：https://blog.csdn.net/u012702547/article/details/78224483http://www.ityouknow.com/springcloud/2017/05/18/hystrix-dashboard-turbine.htmlhttps://blog.csdn.net/dengqiang123456/article/details/76223521https://blog.csdn.net/forezp/article/details/70233227]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Turbine</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06、Hystrix - 断路器之在Feign中的使用]]></title>
    <url>%2FSpringCloud-006%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Eureka Version：2.0.0.RELEASE Feign Version：2.0.0.RELEASE Hystrix Version：1.4.4.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在上一篇的文章中已经介绍了Hystrix在Ribbon中的使用，我们知道Ribbon和Feign所完成的功能都是服务消费，本篇文章将会介绍Hystrix断路器在Feign中的使用。 修改itest-feign工程加入断路器1. 不需要修改pom文件 如果只是开启Feign的断路器功能不需要在pom文件中额外加入hystrix依赖 2. 修改相关代码 (1) Step：添加断路器回调方法，实现先前接口IFeignService新建回调类：FeignServiceHystrix (2) Step：然后修改接口IFeignService指定回调类 (3) Step：最后还需要修改application.yml开启断路器功能 3. 启动项目进行测试 (1) Step：先后启动itest-server，itest-client，itest-feign三个工程后打开: http://localhost:8761 可以看到如下页面 (2) Setp：打开浏览器输入: http://localhost:8765/testFeign?name=rocye 可以看到如下页面 (3) Setp：接下来关闭itest-client工程，查看断路器是否生效（需要等几秒刷新上面的页面） 由此可见，断路器已经生效了。 4. 加入Hystrix Dashboard (断路器仪表盘) (1) Step：在pom文件中加入hystrix dashboard依赖 12345678910111213141516&lt;!-- 2.加入断路器仪表盘功能 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt; (2) Setp：在启动类上加入注解@EnableHystrixDashboard用于开启断路器仪表盘功能，同时加入hystrix.stream的Servlet (3) Setp：重启itest-feign工程，打开: http://localhost:8765/hystrix 页面 (4) Setp：然后输入监测地址：http://localhost:8765/hystrix.stream 点击“Moniter Stream”，接下来可以在浏览器中打开: http://localhost:8765/testFeign?name=rocye 多刷新几次可以看到监测的效果如下所示 源码下载：https://github.com/rocye/SpringCloudStudy 总结Feign底层整合了Ribbon，两者相比较而言，声明式的Feign用起来更方便。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_clientshttps://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_dashboardhttps://blog.csdn.net/forezp/article/details/69934399https://blog.csdn.net/yejingtao703/article/details/77683102]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Hystrix</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05、Hystrix - 断路器之在Ribbon中的使用]]></title>
    <url>%2FSpringCloud-005%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Eureka Version：2.0.0.RELEASE Ribbon Version：2.0.0.RELEASE Hystrix Version：1.4.4.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud中可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是常说的“雪崩”效应。为了解决这个问题，业界提出了断路器模型。 断路器简介Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图：较底层的服务如果出现故障，会导致连锁故障。当对特定服务的调用不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。 修改itest-ribbon工程加入断路器1. 修改工程pom.xml文件 在pom文件中加入hystrix依赖 123456&lt;!-- 2.加入断路器功能 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt; 2. 修改相关代码 (1) Step：在启动类上加入注解@EnableHystrixet用于开启断路器功能 (2) Step：然后在测试类TestService对应的接口方法加入注解@HystrixCommand 定义断路器回调方法 123public String testError(String name) &#123; return "hello " + name + ", happen error!";&#125; 3. 启动项目进行测试 (1) Step：先后启动itest-server，itest-client，itest-ribbon三个工程后打开: http://localhost:8761 可以看到如下页面 (2) Setp：打开浏览器输入: http://localhost:8764/testRibbon?name=rocye 可以看到如下页面 (3) Setp：接下来关闭itest-client工程，查看断路器是否生效（需要等几秒刷新上面的页面） 由此可见，断路器已经生效了。 4. 加入Hystrix Dashboard (断路器仪表盘) (1) Step：在pom文件中加入hystrix dashboard依赖 1234567891011&lt;!-- 3.加入断路器仪表盘功能 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt; PS：手动修改POM文件后，如果发现依赖没生效，可以Reimport解决，如下所示 刷新完后看到最终的依赖如下所示 (2) Setp：在启动类上加入注解@EnableHystrixDashboard用于开启断路器仪表盘功能 (3) Setp：重启itest-ribbon工程，打开: http://localhost:8764/hystrix 页面 然后输入监测地址：http://localhost:8764/hystrix.stream 点击“Moniter Stream” 但是无法正常显示数据而是显示：Unable to connect to Command Metric Stream. 查看日志发现报 404 错误，是因为hystrix.stream地址找不到 (4) Setp：解决办法是需要加入hystrix.stream的Servlet 12345678910//断路器仪表盘功能(解决hystrix.stream : 404 : HTTP/1.1 404 )@Beanpublic ServletRegistrationBean getServlet()&#123; HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings("/hystrix.stream"); registrationBean.setName("HystrixMetricsStreamServlet"); return registrationBean;&#125; (5) Setp：然后重启itest-ribbon工程，再次打开: http://localhost:8764/hystrix 页面输入: http://localhost:8764/hystrix.stream 点击按钮就不再报上面的错了，接下来可以在浏览器中打开: http://localhost:8764/testRibbon?name=rocye 多刷新几次可以看到监测的效果如下所示 PS：实心圆：颜色代表健康度（绿-黄-红-橙递减），大小代表并发量；曲线：请求量的变化；其他主要参数如下图红色字体部分： 源码下载：https://github.com/rocye/SpringCloudStudy 总结以上是单结点服务的统计，相对简单，但是生产上为了服务的健壮性都是多结点，当被监控的服务变成了多个，在Dashboard之前需要一个收集器Turbine，此组件以后再专门介绍。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_clientshttps://springcloud.cc/spring-cloud-dalston.html#_circuit_breaker_hystrix_dashboardhttps://blog.csdn.net/forezp/article/details/69934399https://blog.csdn.net/yejingtao703/article/details/77683102]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Ribbon</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04、Feign - 声明式REST客户端]]></title>
    <url>%2FSpringCloud-004%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在上一篇文章中，我们介绍了通过RestTemplate和Ribbon的服务调用及负载均衡的使用，在Spring Cloud中服务之间通过restful方式调用除了前面介绍的Ribbon外还有一种即是本篇要介绍的Feign。 Feign简介Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。 创建Feign客户端1. 在父工程的基础上创建一个Module子工程用作Ribbon负载均衡器 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery,Web及Feign依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 1234567891011server: port: 8765spring: application: name: itest-feigneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 3. 修改相关代码 (1) Step：在启动类上加入注解@EnableEurekaClient和@EnableFeignClients (2) Step：创建feign接口，通过@FeignClient(“服务名”)，来指定调用哪个服务及具体的接口 (3) Step：创建TestController类用于调用IFeignService进行测试 注：这里注入IFeignService接口时可能会在某些IDE中报语法错，可以在上面的接口中加入@Service注解解决些问题 4. 启动项目进行测试 (1) Step：先启动Eureka服务端itest-server，然后修改启动配置，先启动itest-client端口8762，再启动itest-client端口8763 打开: http://localhost:8761 可以看到itest-client两个实例 (2) Setp：最后启动Feign客户端，刷新上面的页面可以看到itest-feign实例 最终我们启动了如下四个实例 (3) Setp：打开浏览器输入: http://localhost:8765/testFeign?name=rocye 多刷新几次页面可以看到8762和8763端口交替出现 由此可见，已经达到了负载均衡的效果。 源码下载：https://github.com/rocye/SpringCloudStudy 总结 服务注册中心：itest-server 端口为8761 两个测试用的服务实例：itest-client 端口为8762和8763，都注册到了Eureka服务端 服务消费实例(即负载均衡器)：itest-feign端口为8765，也注册到了Eureka服务端 从实践上看，采用feign的方式更优雅，而且feign内部也使用了ribbon做负载均衡 参考文章：https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-feignhttps://blog.csdn.net/forezp/article/details/69808079https://blog.csdn.net/jrn1012/article/details/77837658]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03、Ribbon - 客户端负载均衡器]]></title>
    <url>%2FSpringCloud-003%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Sping Boot Version：2.0.3.RELEASE 概述在上一篇文章中，我们介绍了使用Eureka作为服务注册中心，在服务启动后，各个微服务会将自己注册到Eureka server。那么服务之间是如何调用？又是如何进行负载均衡的？本文将介绍服务的调用及负载均衡器Ribbon的使用。 创建Ribbon负载均衡器1. 在父工程的基础上创建一个Module子工程用作Ribbon负载均衡器 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery,Web及Ribbon依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置 1234567891011server: port: 8764spring: application: name: itest-ribboneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 3. 修改相关代码 (1) Step：在启动类上加入注解@EnableEurekaClient，再通过@Bean注入restTemplate，并通过@LoadBalanced开启负载均衡 (2) Step：创建测试类TestService并注入restTemplate，用来调用itest-client服务的”/test”接口 (3) Step：创建TestController类用于调用TestService进行测试 4. 启动项目进行测试 (1) Step：先启动Eureka服务端itest-server，然后修改启动配置，先启动itest-client端口8762，再启动itest-client端口8763 打开: http://localhost:8761 可以看到itest-client两个实例 (2) Setp：最后启动ribbon负载均衡器，刷新上面的页面可以看到itest-ribbon实例 最终我们启动了如下四个实例 (3) Setp：打开浏览器输入: http://localhost:8764/testRibbon?name=rocye 多刷新几次页面可以看到8762和8763端口交替出现 由此可见，已经达到了负载均衡的效果。 源码下载：https://github.com/rocye/SpringCloudStudy 总结 服务注册中心：itest-server 端口为8761 两个测试用的服务实例：itest-client 端口为8762和8763，都注册到了Eureka服务端 服务消费实例(即负载均衡器)：itest-ribbon 端口为8764，也注册到了Eureka服务端 Ribbon是对服务之间调用做负载，是服务之间的负载均衡，Zuul是可以对外部请求做负载均衡 PS：Zuul的负载均衡功能是针对外部请求做负载。客户端ribbon的负载均衡，解决的是服务发起方（在Eureka注册的服务）对被调用的服务的负载，比如我们查询商品服务要调用显示库存和商品明细服务，通过商品服务的接口将两个服务组合，可以减少外部应用的请求。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-ribbonhttps://blog.csdn.net/forezp/article/details/69788938https://blog.csdn.net/jrn1012/article/details/77837658]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02、Eureka - 服务的注册与发现]]></title>
    <url>%2FSpringCloud-002%2F</url>
    <content type="text"><![CDATA[相关框架版本 Spring Cloud Version：Finchley.RELEASE Sping Boot Version：2.0.3.RELEASE 创建Eureka服务器 (eureka server)1. 创建一个Maven主工程 (1) Step：这里不勾选“Create from archetype” (2) Step：自定义GroupId和ArtifactId (3) Step：自定义工程名及路径 (4) Step：创建完成后如下图，因为是空的父工程所以可以将src文件夹删除 2. 在父工程的基础上创建一个Module子工程用作Eureka服务器 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里只需要选择Eureka服务端依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 3. 修改工程配置文件类型为YML并加入配置 (1) Step：修改application.properties为application.yml（注：本工程配置文件将全部采用YML格式） (2) Step：在配置文件中加入如下配置，其中将registerWithEureka和fetchRegistry设置为false标识此为服务端 1234567891011server: port: 8761eureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 4. 在启动类上加入注解@EnableEurekaServer 启动itest-server工程，在浏览器中打开：http://localhost:8761 看到下图所示页面表示Eureka服务端已创建成功 创建Eureka客户端 (eureka client)1. 在父工程的基础上创建一个Module子工程用作Eureka客户端 (1) Step：在父工程上右键选择 New-&gt;Module (2) Step：选择Spring Initializr (3) Step：自定义项目Metadata (4) Step：这里选择Eureka Discovery和Web依赖 (5) Setp：自定义模块名及路径 (6) Setp：创建完成后的pom文件如下图 2. 修改工程配置文件类型为YML并加入配置 修改application.properties为application.yml并在配置文件中加入如下配置，其中service-url(或serviceUrl)配置成服务端地址 1234567891011server: port: 8762spring: application: name: itest-clienteureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 3. 在启动类上加入注解@EnableEurekaClient 4. 依次启动itest-server和itest-client工程，打开：http://localhost:8761 看到下图所示页面表示Eureka节点已创建成功 PS：测试Eureka节点关闭被服务端踢出需要正常退出，不能强制关闭，如下图 5. 创建测试的RestController(上面加入的Web依赖在这里用到) 6. 重启itest-client工程，在浏览器中打开：http://localhost:8762/test?name=rocye 看到下图所示页面 源码下载：https://github.com/rocye/SpringCloudStudy 总结基于IntelliJ IDEA开发工具构建Spring Cloud工程非常简单和方便，合理利用配置步骤中的选择来生成配置文件能减少不必要的错误。 参考文章：https://springcloud.cc/spring-cloud-dalston.html#spring-cloud-eureka-serverhttps://springcloud.cc/spring-cloud-dalston.html#_service_discovery_eureka_clientshttps://blog.csdn.net/forezp/article/details/69696915]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01、从微服务框架到SpringCloud]]></title>
    <url>%2FSpringCloud-001%2F</url>
    <content type="text"><![CDATA[什么是微服务框架对于微服务基础框架可以看作是微服务治理架构的核心内容，包括了对微服务模块的全生命周期管理能力，这个能力包括了微服务网关APP，DevOps，Docker和云集成，安全，负载均衡，服务注册和发现等诸多能力。微服务基础框架确实不是简单的微服务网关，而是对整个微服务基础环境的支撑和管控。 Netflix的微服务框架Netflix是一家成功实践微服务架构的互联网公司，几年前，Netflix把几乎整个微服务框架栈开源贡献给了社区，这些框架和组件包括： Eureka：服务注册发现框架 Zuul：服务网关 Karyon：服务端框架 Ribbon：客户端框架 Hystrix：服务容错组件 Archaius：服务配置组件 Servo：Metrics组件 Blitz4j：日志组件 下图展示了基于这些组件构建的一个微服务框架体系： Netflix的开源框架组件已经在Netflix的大规模分布式微服务环境中经过多年的生产实战验证，正逐步被社区接受为构造微服务框架的标准组件。Pivotal去年推出的Spring Cloud开源产品，主要是基于对Netflix开源组件的进一步封装，方便Spring开发人员构建微服务基础框架。 微服务化要点关联图了解了Netflix的微服务框架核心组件之后，我们很有必要总览一下这些组件之间的关系，这样更有利于对整个微服务框架的理解，接下来借用网易云的一张架构图，就能很清晰的了解这些组件之间的关系了： Spring CloudSpring Cloud正是对Netflix的多个开源组件进一步的封装而成，同时又实现了和云端平台及Spring Boot开发框架很好的集成。Spring Cloud 为开发者提供了在分布式系统（配置管理，服务发现，熔断，路由，微代理，控制总线，一次性token，全局锁，leader选举，分布式session，集群状态等等）中快速构建的工具，使用Spring Cloud的开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。 Spring Cloud Netflix，该项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路有（Zuul），客户端负载均衡（Ribbon）等。 当然Spring Cloud还有额外扩展的其它很多组件，包括了服务链路监控和跟踪（很关键的一个功能），消息总线，数据流处理，批量任务处理等。而对于整个Spring Cloud微服务框架简单来说，即是：你只要划分到你的微服务组件和模块，并定义好需要暴露的API接口，那么剩下的整个开发和传统方式没有太大的区别，你开发完成的组件集成起来就是一个分布式可扩展的微服务环境。里面设计到的接口发布，服务注册，服务调用和路由，服务监控，健康检测和流控等都会由微服务框架来帮你完成。 PS：正是有了成熟的微服务框架，我们才更应该将微服务架构设计重心从技术底层转移到组件划分和接口设计上。 Spring Cloud VS DubboR1：背景Dubbo：是阿里巴巴服务化治理的核心框架，并被广泛应用于阿里巴巴集团的各成员站点。 Spring Cloud：是Spring Source的产物，Spring社区的强大背书可以说是Java企业界最有影响力的组织了，除了Spring Source之外，还有Pivotal和Netfix是其强大的后盾与技术输出。其中Netflix开源的整套微服务架构套件是Spring Cloud的核心。 R2：社区活跃度我们选择一个开源框架，社区的活跃度是我们极为关注的一个要点。社区越活跃，解决问题的速度越快，框架也会越来越完善，不然当我们碰到问题，就不得不自己解决。而对于团队来说，也就意味着我们不得不自己去维护框架的源码，这对于团队来说也将会是一个很大的负担。 Dubbo ：https://github.com/dubbo Spring Cloud ：https://github.com/spring-cloud 小结：在社区活跃度上，Spring Cloud毋庸置疑的优于Dubbo，这对于没有大量精力与财力维护这部分开源内容的团队来说，Spring Cloud会是更优的选择。 R3：架构完整度根据微服务架构在各方面的要素，看看Spring Cloud和Dubbo都提供了哪些支持： Dubbo Spring Cloud 服务注册中心 Zookeeper Spring Cloud Netflix Eureka 服务调用方式 RPC REST API 服务网关 无 Spring Cloud Netflix Zuul 断路器 不完善 Spring Cloud Netflix Hystrix 分布式配置 无 Spring Cloud Config 服务跟踪 无 Spring Cloud Sleuth 消息总线 无 Spring Cloud Bus 数据流 无 Spring Cloud Stream 批量任务 无 Spring Cloud Task …… …… …… Dubbo对于上表中总结为“无”的组件不代表不能实现，而只是Dubbo框架自身不提供，需要另外整合以实现对应的功能，比如： 分布式配置：可以使用淘宝的diamond、百度的disconf来实现分布式配置管理。但是Spring Cloud中的Config组件除了提供配置管理之外，由于其存储可以使用git，因此它天然的实现了配置内容的版本管理，可以完美的与应用版本管理整合起来。服务跟踪：可以使用京东开源的Hydra批量任务：可以使用当当开源的Elastic-Job…… R4：对比总结通过上面几个环节上的分析，打个不恰当的比喻：使用Dubbo构建的微服务架构就像组装电脑，各环节我们的选择自由度很高，但是最终结果很有可能因为一条内存质量不行就点不亮了，总是让人不怎么放心，但是如果你是一名高手，那这些都不是问题；而Spring Cloud就像品牌机，在Spring Source的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性，但是如果要在使用非原装组件外的东西，就需要对其基础有足够的了解。 参考文章：http://blog.sina.com.cn/s/blog_493a84550102wkna.htmlhttp://blog.sina.com.cn/s/blog_493a84550102wkp2.htmlhttp://blog.didispace.com/microservice-framework/]]></content>
      <categories>
        <category>SpringCloud笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务框架</tag>
      </tags>
  </entry>
</search>
